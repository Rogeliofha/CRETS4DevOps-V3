Id,detail,Justification,Discussion 
Mod.1.,Compatibility and Connectivity,,
Mod.1.1.,"The software must utilise standardised APIs (Application Programming Interfaces) and communication protocols to ensure interoperability with other applications. For example, RESTful APIs, SOAP, gRPC, and data transfer protocols such as HTTP or HTTPS.",,
Mod.1.2.,"Common and widely accepted data formats (JSON, XML, CSV) should be used to ensure that data can be easily exchanged and understood by other systems.",,
Mod.1.3.,"Regression testing should be carried out to ensure that new versions of the software do not introduce errors or compatibility issues with previous versions. Continuous Integration (CI) tools such as Jenkins, CircleCI, or GitHub Actions may be used.",,
Mod.1.4.,Network monitoring tools such as Nagios and Zabbix should be implemented to supervise connectivity and the performance of communications between systems.,,
Mod.1.5.,Active connections and network resources must be managed to ensure efficient operation. This includes the use of patterns such as persistent connection and handling of pending connections to improve performance.,,
Mod.2.,Integration and Updating,,
Mod.2.1.,Integration manuals and guides should be created to clearly explain how to add new components and services to the existing system.,,
Mod.2.2.,"The system should be divided into independent microservices that communicate with each other via APIs. This allows each microservice to be developed, deployed, and scaled autonomously.",,
Mod.2.3.,"Configuration management systems should be implemented to manage and version changes in both infrastructure and software, facilitating updates and enabling rollbacks if necessary.",,
Mod.2.4.,Regression tests should be implemented to ensure that updates do not introduce errors or affect existing functionalities.,,
Mod.2.5.,"CI/CD pipelines should be configured using tools such as Jenkins, GitLab CI, or GitHub Actions.",,
Esc.1.,Design and Implementation Process,,
Esc.1.1.,Programmers must write efficient algorithms.,,
Esc.1.2.,The software architecture should have as few layers as possible.,"The use of dynamic libraries, independent modules, or any other software system that adds layers to the final system architecture increases complexity and, by extension, the entropy of the software.",
Esc.2.,Green Analysis Process,,
Esc.2.1.,High energy-efficiency hardware should be utilised to minimise energy consumption as capacity increases.,,
Esc.2.2.,"Energy management policies should be implemented, such as the use of low-power modes and CPU frequency adjustment.",,
Esc.3.,Load Distribution,,
Esc.3.1.,"Load balancing techniques should be employed to distribute processes evenly across multiple servers, optimising resource usage.",,
Esc.3.2.,A microservices architecture should be implemented to allow different parts of the application to be scaled independently.,,
Esc.3.3.,"Continuous monitoring systems and scenario analysis should be implemented to anticipate demand and dynamically adjust capacity, thereby avoiding system saturation.",,
Fle.1.,Agile Methodologies,,
Fle.1.1.,"Create and maintain a library of reusable components that can be integrated into different projects, thereby promoting efficiency and sustainability.",,
Fle.1.2.,"Implement agile methodologies such as Scrum, which enable short iterations with continuous requirements reviews.",,
Fle.1.3.,Establish change control processes that include the assessment of the impact of changes on requirements.,,
Fle.1.4.,Use techniques that allow requirements to be dynamically prioritised and enable the identification of critical requirements according to changes.,,
Reu.1.,Elimination Process,,
Reu.1.1.,"When a product or service is retired, the code must be preserved for potential reuse in future projects.",This will minimise development costs.,Code reuse for other projects should not be limited to this process; it is also possible (and advisable) to do so during development and deployment.
Reu.2.,Component Library,,
Reu.2.1.,"Develop a component library within a technological tool such as GitHub, enabling components to be reused across multiple applications and projects.",,
Reu.2.2.,Create standards for the creation and usage of reusable components to ensure their consistency.,,
Reu.2.3.,Create and maintain documentation for the developed components to facilitate their reuse.,,
Reu.3.,Use of Templates,,
Reu.3.1.,Create and utilise templates that can be adapted to different projects.,,
Reu.3.2.,Develop or adapt frameworks that facilitate the construction of reusable applications.,,
Reu.4.,Change Control,,
Reu.4.1.,"Create a versioning system for reusable components, allowing for improvements and corrections of identified errors to be easily integrated.",,
Reu.4.2.,Keep the change history up to date.,,
Man.1.,Maintenance Process,,
Man.1.1.,The developed code must be readable.,"If a programme is easy to understand, it will be quicker, easier, and more energy-efficient to make changes to it.",
Man.1.2.,Code documentation must always be available and consistent with the actual code.,,
Man.1.3.,Security updates must be created to prevent potential software system failures.,,
Man.2.,Use of Open Source Programmes and Development Environments,"These types of programmes are not developed by companies solely seeking profit, but are maintained, in most cases, by a community of developers aiming to eliminate errors and improve the product. The difference lies in the fact that companies will seek to sell new versions, always intending to create a new product rather than maintain the current one.",
Man.3.,Divergent Change,,
Man.3.1.,"Apply the ""Extract Class"" or ""Extract Superclass"" refactoring when many changes need to be made to a single class to introduce new functionality.","This improves code organisation, reduces duplicated code, and simplifies maintenance.",
Man.4.,Shotgun Surgery,,
Man.4.1.,"Apply the ""Move Field"" and ""Move Method"" refactorings to an appropriate class (created for this purpose if necessary) when a small change in one class requires modifications in other classes and methods.","This improves code organisation, reduces duplicated code, and simplifies maintenance.",
Man.5.,Feature Envy,,
Man.5.1.,"Apply the ""Move Method"" refactoring if possible, or ""Extract Method"" if only part of the code accesses data from another class, when a method is more interested in another class than its own (e.g. reads attributes, data, etc.).",There is less duplicated code and code organisation is improved by bringing methods that manage data closer to those that require them.,
Man.6.,Primitive Obsession,,
Man.6.1.,"Avoid using primitive data types to represent states, objects, or store information.",,
Man.6.1.1.,Implement classes that group primitive data types so that an object represents the information.,,
Man.6.1.2.,"If variables encode complex data, try to replace them with classes, subclasses, or by using the State/Strategy patterns.",The code becomes more flexible and its comprehensibility increases.,
Man.7.,Data Class,,
Man.7.1.,The attributes of a data class (which only has attributes and get/set methods) should only be modified using the methods provided by the class.,This improves code comprehensibility.,
Fia.1.,The F.I.R.S.T. Rules must be applied to all developed tests.,,
Fia.1.1.,Fast: Tests shall be fast.,,
Fia.1.1.1.,"If they cannot be executed within an acceptable time frame, they should be scheduled to run less frequently.",,"Tests should be run as frequently as possible, provided their execution does not result in excessive resource consumption and, consequently, higher energy usage. If tests require significant resources to execute, they should be scheduled for less frequent execution. This aims to strike a balance between execution frequency and energy consumption."
Fia.1.2.,Independent: A test must not depend on the execution of any other test.,,
Fia.1.3.,Repeatable: Tests should be programmed to run in any environment and at any time.,,
Fia.1.4.,Automatic validation: Tests must return only a boolean output: pass or fail.,,
Fia.1.5.,Timely: Tests should be written just before the production code that will fulfil them.,,
Fia.2.,Recyclability Process,,
Fia.2.1.,"If the product or service ceases to function, mechanisms must be in place to assist the user in repairing it.",,
Fia.2.2.,"A mechanism for collecting user feedback on product durability should be implemented, based on surveys.",,
Fia.3.,"If there is a process running that requires between 0.2 and 1 second, a loading screen with a waiting message must be implemented.",,
Fia.4.,Fonts and Typography,,
Fia.4.1.,Use a maximum of two different fonts in your service.,,
Fia.4.2.,"Use fonts optimised for screen display rather than print, such as Georgia or Verdana.",,
Fia.4.3.,Use a maximum of three different text font sizes.,,
Seg.1.,Credentials,,
Seg.1.1.,Users must log in with a unique and secure username and password.,,
Seg.1.2.,"Passwords must comply with complexity requirements (minimum length, combination of letters, numbers, and special characters), and should be changed periodically.",,
Seg.1.3.,"When using mobile applications, two-step authentication must be implemented (via SMS message or email).",,
Seg.1.4.,All mobile devices used must be authorised and registered by the system administrator.,,
Seg.1.5.,Training should be provided on practices to protect users? credentials.,,
Seg.1.6.,Continuous audits of access to software and servers should be conducted.,,
Seg.2.,The Principle of Information Hiding must be applied: the implementation details of a module should be hidden from other modules and only accessed through the public interface of that module.,,
Seg.3.,"If the application or service is to be developed following the Object-Oriented Programming paradigm, the Law of Demeter must be applied: a method f of class C should only call methods of C, of an object created (or passed as an argument) by f, and of an instance variable of C.",,
Seg.4.,Data Validation,,
Seg.4.1.,Mechanisms for validating and controlling input data must be implemented to ensure they are correct and free from inconsistencies.,,
Seg.4.2.,Digital signatures should be used to verify the integrity of data and ensure it has not been modified without authorisation.,,
Seg.4.3.,"Data must be encrypted during transfer and storage, protected from unauthorised access and data theft.",,
Seg.4.4.,"Strong encryption algorithms, such as AES-256, must be used to guarantee the protection of critical information.",,
Int.1.,Open Standards,,
Int.1.1.,"Implement open standards such as HTTP, HTTPS, REST, SOAP, JSON, XML, and other protocols that enable compatibility between different systems.",,
Int.1.2.,"Use standardised data formats, such as JSON, XML, or CSV, to facilitate the exchange of information between disparate systems.",,
Int.1.3.,Develop well-defined and documented APIs to enable other systems to interact with the software in a clear and straightforward manner.,,
Int.2.,Continuous Monitoring,,
Int.2.1.,"Implement continuous monitoring systems to oversee the interoperability and performance of the systems, detecting any issues.",,
Int.2.2.,Configure alerts and notifications to inform administrators of any interoperability issues.,,
Int.2.3.,Provide technical support to assist in resolving interoperability problems and to facilitate the continuous integration of new systems.,,
Efi.1.,Frameworks,,
Efi.1.1.,Different profiles or modes should be created to save energy by switching off or hibernating applications that are not in use during periods of inactivity.,,
Efi.2.,Green Computing,,
Efi.2.1.,"If the system needs to activate external devices or peripherals, it should be programmed so that they are only activated when required.",This will prevent excessive use and reduce the energy cost of keeping them active when not in use.,
Efi.3.,Performance Metrics,,
Efi.3.1.,CPU usage frequency information should be used to quantify the energy dissipation that occurs during development.,,
Efi.4.,A mechanism for shutting down or hibernating development systems after a period of inactivity should be implemented.,,
Efi.5.,"If such a shutdown or hibernation system is not possible, a plain white screensaver, without text or graphics, should be used on systems with cathode ray or LCD display technology.","Screensavers without text or graphics generate fewer connections with the GPU, reducing energy consumption.",
Efi.6.,"If such a shutdown or hibernation system is not possible, a plain black screensaver, without text or graphics, should be used on systems with OLED technology.","With OLED technology, each pixel emits its own light, so if black is displayed, no pixels are activated.",
Efi.7.,"If application users? monitors use cathode ray or LCD technology, white should be used for loading screens.",,
Efi.8.,"If application users? monitors use OLED technology, black should be used for loading screens.",,
Efi.9.,Image Representation,,
Efi.9.1.,"If it is necessary to display a diagram or flat graphic that does not need to be scaled, the PNG or GIF format should be used.",,
Efi.9.2.,The JPG format should be used for photographs.,,
Efi.9.3.,The SVG format should be used to maintain sharpness for scalable graphics.,,
Efi.9.4.,CSS Sprites should be used instead of JPG images to display navigation buttons and icons.,"Browsers cache CSS images (such as back/forward navigation arrows, classic home page icons, icons for save, print, etc.), thus eliminating the HTTP requests that the browser would otherwise need to make for server-hosted images.",
